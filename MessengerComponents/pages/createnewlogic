import React from "react";
import { Query, Mutation } from "react-apollo";
import moment from "moment";
import SearchInput from "../components/SearchInput";
import ConversationList from "../components/ConversationList";
import UserList from "../components/UserList";
import Conversation from "../components/Conversation";
import MY_CONVERSATIONS_QUERY from "../graphql/queries/myConversations";
import USERS_QUERY from "../graphql/queries/users";
import SEND_TEXT_MESSAGE_MUTATION from "../graphql/mutations/sendTextMessage";
import CREATE_CONVERSATION_MUTATION from "../graphql/mutations/createConversation";
import TEXT_ADDED_SUBSCRIPTION from "../graphql/subscriptions/text";
import USER_ADDED_SUBSCRIPTION from "../graphql/subscriptions/user";
import { Messaging } from "../components/MessengerStyles";

const contexts = {
  CONVERSATION: "CONVERSATION",
  USER: "USER",
};

class Messenger extends React.Component {
  state = {
    searchInput: "",
    context: {
      name: null,
      id: null,
      data: {},
    },
    updatedConversationsList: [],
  };

  componentDidMount() {
    this.openCreatedChat();
  }

  openCreatedChat() {
    let { context } = this.state;
    const obj = JSON.parse(localStorage.getItem("newChat"));
    if (obj) {
      Object.assign(context, obj);
      console.log("object from local", context);
      this.setState({ context });
      localStorage.removeItem("newChat");
    }
  }

  getSearchInput() {
    return (
      <SearchInput
        onChange={(searchInput) => {
          this.setState(
            (prevState) => ({
              ...prevState,
              searchInput,
            }),
            () => {
              console.error("this search state", this.state);
            }
          );
        }}
      />
    );
  }

  getConversationList() {
    return (
      <Query query={MY_CONVERSATIONS_QUERY} fetchPolicy="network-only">
        {({ loading, error, data, subscribeToMore }) => {
          if (!data) return <h1> loading...</h1>;
          if (data) {
            let oldConversations =[];
            let newConversations =[];
          data.me.conversations.filter(conversation => {
             if(conversation.texts.length>0){
               oldConversations.push(conversation);
             } else {
              newConversations.push(conversation);
             }
            });
            console.log('old & new', oldConversations, newConversations);
            let conversationsList;
            // this.setState({ initialConversations: data.me.conversations });
            // console.log('data.me.convs', data.me.conversations);
            return (
              <ConversationList
                onClick={(conversation) => {
                  this.setState((prevState) => ({
                    ...prevState,
                    context: {
                      name: contexts.CONVERSATION,
                      id: conversation.id,
                      data: conversation,
                    },
                  }));
                }}
                {...{
                  loading,
                  error,
                  conversations: oldConversations,
                  emptyConversations: newConversations,
                  currentUser: data.me.id,
                  // .filter((conversation) =>
                  //   this.state.searchInput !== ""
                  //     ? conversation.name
                  //         .toUpperCase()
                  //         .includes(this.state.searchInput.toUpperCase())
                  //     : conversation
                  // ),
                }}
                subscribeToNewConversationMessages={() =>
                  subscribeToMore({
                    document: TEXT_ADDED_SUBSCRIPTION,
                    fetchPolicy: "network-only",
                    variables: {},
                    updateQuery: (prev, { subscriptionData }) => {
                      if (!subscriptionData.data) return prev;
                      if (subscriptionData.data) {
                        const newText = subscriptionData.data.text.node;
                        const conversationExists = prev.me.conversations.filter(
                          (conversation) => {
                            return conversation.id === newText.conversation.id;
                          }
                        );

                        if (conversationExists.length > 0) {
                          // Add message to an existing conversation
                          const conversations = prev.me.conversations.map(
                            (conversation) => {
                              if (conversation.id === conversationExists.id) {
                                const { conversation: chat } = newText;
                                return {
                                  ...conversation,
                                  texts: chat.texts,
                                };
                              }

                              return conversation;
                            }
                          );

                          return {
                            ...prev,
                            me: {
                              ...prev.me,
                              conversations,
                            },
                          };
                        } else {
                          // Add a new conversation to conversations along with the new message
                          if (!conversationsList) {
                            conversationsList = data.me.conversations;
                          }
                          const { conversation } = newText;
                          conversationsList.push(conversation);
                          this.setState({
                            updatedConversationsList: conversationsList,
                          });
                          return {
                            ...prev,
                            me: {
                              ...prev.me,
                              conversations: [
                                ...prev.me.conversations,
                                conversation,
                              ],
                            },
                          };
                        }
                      }
                    },
                  })
                }
              />
            );
          }
        }}
      </Query>
    );
  }

  getUserList() {
    return (
      <Query query={USERS_QUERY}>
        {({ loading, error, data, subscribeToMore }) => {
          if (!data) return <h1> loading...</h1>;
          if (data)
            return (
              <UserList
                onClick={(user) => {
                  this.setState((prevState) => ({
                    ...prevState,
                    context: { name: contexts.USER, id: user.id, data: user },
                  }));
                }}
                {...{
                  loading,
                  error,
                  users: data.users.filter((user) =>
                    this.state.searchInput !== ""
                      ? user.name
                          .toUpperCase()
                          .includes(this.state.searchInput.toUpperCase())
                      : user
                  ),
                }}
                subscribeToNewUsers={() =>
                  subscribeToMore({
                    document: USER_ADDED_SUBSCRIPTION,
                    variables: {},
                    updateQuery: (prev, { subscriptionData }) => {
                      if (!subscriptionData.data) return prev;

                      const newUser = subscriptionData.data.user.node;

                      return {
                        ...prev,
                        users: [...prev.users, newUser],
                      };
                    },
                  })
                }
              />
            );
        }}
      </Query>
    );
  }

  getTextMessageList() {
    return (
      <Query query={MY_CONVERSATIONS_QUERY}>
        {({ loading, error, data }) => {
          if (!data) return <h1> loading...</h1>;
          let ConversationName = [];
          const conversations = data.me.conversations.map((conversation) => {
            ConversationName = conversation.participants.filter((user) =>
              user.id !== data.me.id ? user : null
            );
            return {
              ...conversation,
              texts: conversation.texts.filter((textMessage) =>
                this.state.searchInput !== ""
                  ? textMessage.text
                      .toUpperCase()
                      .includes(this.state.searchInput.toUpperCase())
                  : textMessage
              ),
            };
          });

          return (
            <ul
              className={[
                "list-reset",
                this.state.searchInput === "" && "hidden",
              ].join(" ")}
            >
              <li className="font-bold m-4">Messages</li>
              {conversations.map((conversation) => (
                <React.Fragment key={conversation.id}>
                  {conversation.texts.map((textMessage) => (
                    <li
                      key={textMessage.id}
                      className="px-4 py-2 hover:bg-grey-lightest cursor-pointer flex items-center"
                      onClick={(e) => {
                        this.setState((prevState) => ({
                          ...prevState,
                          context: {
                            name: contexts.CONVERSATION,
                            id: conversation.id,
                            data: conversation,
                          },
                        }));
                      }}
                    >
                      {/* <div className="mr-3">
                        <Avatar initials={conversation.name} />
                      </div> */}
                      <div className="text-sm flex-1">
                        <div className="font-bold">
                          {ConversationName[0].name}
                        </div>
                        <div className="flex justify-between text-grey-dark">
                          <div
                            className="mt-1 w-32 overflow-hidden whitespace-no-wrap"
                            style={{
                              textOverflow: "ellipsis",
                            }}
                          >
                            <span>
                              {data.me.id === textMessage.author.id
                                ? "You"
                                : textMessage.author.name}
                              : {textMessage.text}
                            </span>
                            );
                          </div>
                        </div>
                      </div>
                      <div className="text-xs text-grey-dark">
                        {moment(textMessage.createdAt).fromNow()}
                      </div>
                    </li>
                  ))}
                </React.Fragment>
              ))}
            </ul>
          );
        }}
      </Query>
    );
  }

  getConversationNotSelected() {
    return (
      <div className="flex-1 flex flex-col h-full items-center justify-center">
        {/* <div className="text-5xl">{randomEmoji()}</div> */}
        <div className="mt-6">Coding is awesome!</div>
      </div>
    );
  }

  getConversations() {
    const { context } = this.state;
    return (
      <Mutation mutation={SEND_TEXT_MESSAGE_MUTATION}>
        {(sendTextMessage, { loading, error, data }) => (
          <Query query={MY_CONVERSATIONS_QUERY}>
            {({ loading, error, data }) => {
              if (!data) return <h2>loading...</h2>;
              if (data) {
                return (
                  <React.Fragment>
                    {data.me.conversations.map((conversation) => (
                      <div
                        key={conversation.id}
                        className={[
                          "h-full",
                          context.name === contexts.CONVERSATION &&
                          context.id === conversation.id
                            ? "block"
                            : "hidden",
                        ].join(" ")}
                      >
                        <Conversation
                          conversation={conversation}
                          me={data.me.id}
                          onTextMessageSend={async (text) => {
                            await sendTextMessage({
                              variables: {
                                conversationId: conversation.id,
                                text,
                              },
                            });
                            this.getConversationList();
                          }}
                        />
                      </div>
                    ))}
                  </React.Fragment>
                );
              }
            }}
          </Query>
        )}
      </Mutation>
    );
  }

  getWindowsFromContext({ me }) {
    let getWindow;
    const { context } = this.state;
    if (!context.name || !context) {
      getWindow = this.getConversationNotSelected();
    }
    if (context.name === contexts.USER) {
      const conversationExists = me.conversations.filter((conversation) => {
        return (
          conversation.participants.length === 2 &&
          conversation.participants.find(
            (participant) => participant.id === context.id
          )
        );
      });
      if (conversationExists.length > 0) {
        this.setState((prevState) => ({
          ...prevState,
          context: {
            name: contexts.CONVERSATION,
            id: conversationExists.id,
            data: conversationExists,
          },
        }));
      } else {
        getWindow = (
          <Mutation mutation={CREATE_CONVERSATION_MUTATION}>
            {(createConversation, { loading, error }) => (
              <Conversation
                conversation={{
                  id: null,
                  name: context.data.name,
                  participants: [],
                  texts: [],
                }}
                onTextMessageSend={async (text) => {
                  const res = await createConversation({
                    variables: {
                      participant: [context.id],
                      text,
                    },
                  });
                  this.setState((prevState) => ({
                    ...prevState,
                    context: {
                      name: contexts.CONVERSATION,
                      id: res.data.createConversation.id,
                      data: res.data.createConversation,
                    },
                  }));
                  const newChat = {
                    name: contexts.CONVERSATION,
                    id: res.data.createConversation.id,
                    data: res.data.createConversation,
                  };
                  localStorage.setItem("newChat", JSON.stringify(newChat));
                  window.location.reload();
                }}
              />
            )}
          </Mutation>
        );
      }
    }

    return (
      <React.Fragment>
        {getWindow}
        {this.getConversations()}
      </React.Fragment>
    );
  }

  render() {
    return (
      <Messaging>
        <div className="scrollable sidebar">
          <div>{this.getSearchInput()}</div>
          {this.getConversationList()}
          {/* {this.getUserList()} */}
          {this.getTextMessageList()}
        </div>
        <div className="scrollable vertical-line" />
        <div className="scrollable content">
          <Query query={MY_CONVERSATIONS_QUERY}>
            {({ loading, error, data }) => {
              if (!data) {
                return <h1> dont worry something wrong but will be fixed</h1>;
              }
              if (data) {
                return this.getWindowsFromContext({ me: data.me });
              }
              return <h2> instead of null</h2>;
            }}
          </Query>
        </div>
      </Messaging>
    );
  }
}

export default Messenger;
